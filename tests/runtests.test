package require tcltest
namespace import tcltest::*

# Add module dir to tm paths
set ThisScriptDir [file dirname [info script]]
set ModuleDir [file normalize [file join $ThisScriptDir ..]]
::tcl::tm::path add $ModuleDir

source [file join $ThisScriptDir test_helpers.tcl]

package require xproc
xproc::remove tests -match {*::xproc*}

xproc::proc addNums2 {a b} {
  expr {$a+$b}
} -description {
  Add two numbers together and return the result

  This could work as follows:
    addNums2 7 9      ; # Would return 16
} -test {{t} {
  set cases {
    {input {7 9} result 16}
    {input {2 3} result 18}
    {input {2 4} result 6}
  }
  set i 0
  foreach c $cases {
    dict with c {
      set got [addNums2 {*}$input]
      if {$got != $result} {
        xproc::fail $t "($i) got: $got, want: $result"
      }
    }
    incr i
  }
}}


xproc::proc addNums3 {a b} {
  expr {$a+$b}
} -description {
  Add two numbers together and return the result

  This could work as follows:
    addNums3 7 9      ; # Would return 16
} -test {{t} {
  set cases {
    {input {7 9} result 15}
    {input {2 3} result 5}
    {input {2 4} result 7}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {addNums3 {*}$input}
  }}
}}


xproc::proc addNums4 {a b} {
  expr {$a+$b}
} -description {
  Add two numbers together and return the result

  This could work as follows:
    addNums4 7 9      ; # Would return 16
} -test {{t} {
  set cases {
    {input {7 9} result 16}
    {input {2 3} result 5}
    {input {2 4} result 6}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {addNums4 {*}$input}
  }}
}}


proc addNums5 {a b} {
  expr {$a+$b}
}
xproc::describe addNums5 {
  Add two numbers together and return the result

  This could work as follows:
    addNums5 7 9      ; # Would return 16
}
xproc::test addNums5 {{t} {
  set cases {
    {input {7 9} result 16}
    {input {2 3} result 18}
    {input {2 4} result 6}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {addNums5 {*}$input}
  }}
}}


xproc::proc subNums {a b} {
  expr {$a-$b}
} -description {
  Subtract one number from another and return the result

  This could work as follows:
    subNums 7 9      ; # Would return -2
} -test {{t} {
  set cases {
    {input {7 9} result -2}
    {input {5 4} result 1}
    {input {2 4} result -2}
    {input {4 4} result 0}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {subNums {*}$input}
  }}
}}


namespace eval aTestNamespace {
  xproc::proc cmdA {} {
    return "defined inside eval aTestNamespace"
  } -description {
    this is a description of cmdA
  } -test {{t} {
    set got [cmdA]
    set want "defined inside eval aTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } aTestNamespace}
}

xproc::proc aTestNamespace::cmdB {} {
  return "defined outside eval aTestNamespace"
} -description {
  this is a description of cmdB
} -test {{t} {
  set got [aTestNamespace::cmdB]
  set want "defined outside eval aTestNamespace"
  if {$got ne $want} {
    xproc::fail $t  "got: $got, want: $want"
  }
}}


xproc::proc ::aTestNamespace::cmdC {} {
  return "defined outside eval aTestNamespace"
} -description {
  this is a description of cmdC
} -test {{t} {
  set got [aTestNamespace::cmdC]
  set want "defined outside eval aTestNamespace"
  if {$got ne $want} {
    xproc::fail $t  "got: $got, want: $want"
  }
}}


# This shouldn't appear in tests or descriptions because is removed in both
namespace eval bTestNamespace {
  xproc::proc cmdA {} {
    return "defined inside eval bTestNamespace"
  } -description {
    this is a description of cmdA
  } -test {{t} {
    set got [cmdA]
    set want "defined inside eval bTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } bTestNamespace}
  xproc::proc cmdB {} {
    return "defined inside eval bTestNamespace"
  } -description {
    this is a description of cmdB
  } -test {{t} {
    set got [cmdB]
    set want "defined inside eval bTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } bTestNamespace}
}

#
# This shouldn't appear in tests or descriptions because is removed in both.
# This will be removed using remove all -match ...
namespace eval bbTestNamespace {
  xproc::proc cmdA {} {
    return "defined inside eval bbTestNamespace"
  } -description {
    this is a description of cmdA
  } -test {{t} {
    set got [cmdA]
    set want "defined inside eval bbTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } bbTestNamespace}
  xproc::proc cmdB {} {
    return "defined inside eval bbTestNamespace"
  } -description {
    this is a description of cmdB
  } -test {{t} {
    set got [cmdB]
    set want "defined inside eval bbTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } bbTestNamespace}
}


# This shouldn't appear in tests because is removed
namespace eval cTestNamespace {
  xproc::proc cmdA {} {
    return "defined inside eval cTestNamespace"
  } -description {
    this is a description of cmdA
  } -test {{t} {
    set got [cmdA]
    set want "defined inside eval cTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } cTestNamespace}
}


# This shouldn't appear in descriptions because is removed
namespace eval dTestNamespace {
  xproc::proc cmdA {} {
    return "defined inside eval dTestNamespace"
  } -description {
    this is a description of cmdA
  } -test {{t} {
    set got [cmdA]
    set want "defined inside eval dTestNamespace"
    if {$got ne $want} {
      xproc::fail $t  "got: $got, want: $want"
    }
  } dTestNamespace}
}

# Remove relevant namespaces as described above
xproc::remove tests -match {::bTestName* ::cTestName*}
xproc::remove descriptions -match {::bTestName* ::dTestName*}
xproc::remove all -match {::bbTestName*}


test proc-1 {Allows normal definition of a proc} -body {
  xproc::proc addNums {a b} {expr {$a+$b}}
  addNums 7 9
} -result {16}


xproc::proc waitMS {ms} {
  after $ms
} -test {{t} {
  set timeStart [clock microseconds]
  waitMS 100
  set timeEnd [clock microseconds]
  set timeElapsed [expr {$timeEnd-$timeStart}]
  if {$timeElapsed < 100000 || $timeElapsed > 1000000} {
    xproc::fail $t  "timeElapsed: $timeElapsed"
  }
}}

xproc::proc waitMSFail {ms} {
  after $ms
} -test {{t} {
  set timeStart [clock microseconds]
  waitMSFail 100
  xproc::fail $t  "here is an error"
}}


test runTests-2 {Ensure timings work} -body {
  xproc::runTests -verbose 2 -match {*waitMS*}
} -cleanup {
  xproc::remove all -match {*waitMS*}
} -output {=== SKIP   ::addNums2/1
=== SKIP   ::addNums3/1
=== SKIP   ::addNums4/1
=== SKIP   ::addNums5/1
=== SKIP   ::subNums/1
=== SKIP   ::aTestNamespace::cmdA/1
=== SKIP   ::aTestNamespace::cmdB/1
=== SKIP   ::aTestNamespace::cmdC/1
=== SKIP   ::dTestNamespace::cmdA/1
=== RUN   ::waitMS/1
--- PASS  ::waitMS/1 (0.10s)
=== RUN   ::waitMSFail/1
--- FAIL  ::waitMSFail/1 (0.10s)
          here is an error

Total: 11,  Passed: 1,  Skipped: 9,  Failed: 1
} -result [dict create total 11 passed 1 skipped 9 failed 1]


test runTests-3 {Provide correct fail output with errors} -setup {
  xproc::proc raiseErrorCmd {a b} {
    expr {$a-$c}
  } -test {{t} {
    raiseErrorCmd 4 5
  }}
  xproc::proc addNumsInTestCaseNotEqResult {a b} {
    expr {$a+$b}
  } -test {{t} {
    set cases {
      {input {7 9} result 16}
      {input {2 3} result 17}
      {input {2 4} result 4}
      {input {2 4} result 9}
    }
    set i 0
    foreach c $cases {
      if {$i == 3} {
        error "Time to fail - i: $i"
      }
      dict with c {
        set got [addNumsInTestCaseNotEqResult {*}$input]
        if {$got != $result} {
          xproc::fail $t  "($i) got: $got, want: $result"
        }
      }
      incr i
    }
  }}

  # Checks if a testCase lambda raises an error it should be recorded
  # even if no result specified
  xproc::proc subNumsTestCaseRaisesErrorNoResult {a b} {
    expr {$a-$b}
  } -description {
    Subtract one number from another and return the result
  } -test {{t} {
    set cases {
      {input {5 4}}
      {input {2 4 7} returnCodes {error}}
      {input {4 4}}
    }
    xproc::testCases $t $cases {{case} {
      dict with case {
        if {[llength $input] == 3} {
          return -code error "too many values in input"
        }
        subNumsTestCaseRaisesErrorNoResult {*}$input
      }
    }}
  }}
  set ch [TestHelpers::channelMonitor new]
} -body {
  set summary [
    xproc::runTests -channel $ch -match {
      ::raiseErrorCmd ::addNumsInT* ::subNumsTe*
    }
  ]
  set channelOutput [TestHelpers::channelMonitor getWriteData $ch]
  set lines [split $channelOutput "\n"]
  set captureMore false
  set captureLines {}
  foreach line $lines {
    if {[string match {--- FAIL*} $line]} {
      lappend captureLines $line
      set captureMore true
    } elseif {$captureMore} {
      lappend captureLines $line
      if {[string match {*while executing} $line]} {
        set captureMore false
      }
    }
  }
  set totalLine [lindex $captureLines end-1]
  set totalLineCorrect [
    regexp {Total: \d+,  Passed: 0,  Skipped: \d+,  Failed: 3} $totalLine
  ]
  set captureLines [lrange $captureLines 0 end-2]
  dict create numFailed [dict get $summary failed] \
              captureLines $captureLines \
              totalLineCorrect $totalLineCorrect
} -cleanup {
  xproc::remove all -match {::addNumsInT* ::raiseErrorCmd ::subNumsTe*}
  close $ch
} -result [dict create numFailed 3 \
  captureLines [list \
    "--- FAIL  ::raiseErrorCmd/1 (0.00s)" \
    "          can't read \"c\": no such variable" \
    "              while executing" \
    "--- FAIL  ::addNumsInTestCaseNotEqResult/1 (0.00s)" \
    "          (1) got: 5, want: 17" \
    "          (2) got: 6, want: 4" \
    "          Time to fail - i: 3" \
    "              while executing" \
    "--- FAIL  ::subNumsTestCaseRaisesErrorNoResult/1 (0.00s)" \
    "          (1) too many values in input" \
    ""
  ] \
  totalLineCorrect 1
]


test runTests-4 {Provide correct test output} -body {
  xproc::runTests
} -output {--- FAIL  ::addNums2/1 (0.00s)
          (1) got: 5, want: 18
--- FAIL  ::addNums3/1 (0.00s)
          (0) got: 16, want: 15
          (2) got: 6, want: 7
--- FAIL  ::addNums5/1 (0.00s)
          (1) got: 5, want: 18

Total: 9,  Passed: 6,  Skipped: 0,  Failed: 3
} -result [dict create total 9 passed 6 skipped 0 failed 3]


test runTests-5 {-verbose 2 should list passing tests} -body {
  xproc::runTests -verbose 2
} -output {=== RUN   ::addNums2/1
--- FAIL  ::addNums2/1 (0.00s)
          (1) got: 5, want: 18
=== RUN   ::addNums3/1
--- FAIL  ::addNums3/1 (0.00s)
          (0) got: 16, want: 15
          (2) got: 6, want: 7
=== RUN   ::addNums4/1
--- PASS  ::addNums4/1 (0.00s)
=== RUN   ::addNums5/1
--- FAIL  ::addNums5/1 (0.00s)
          (1) got: 5, want: 18
=== RUN   ::subNums/1
--- PASS  ::subNums/1 (0.00s)
=== RUN   ::aTestNamespace::cmdA/1
--- PASS  ::aTestNamespace::cmdA/1 (0.00s)
=== RUN   ::aTestNamespace::cmdB/1
--- PASS  ::aTestNamespace::cmdB/1 (0.00s)
=== RUN   ::aTestNamespace::cmdC/1
--- PASS  ::aTestNamespace::cmdC/1 (0.00s)
=== RUN   ::dTestNamespace::cmdA/1
--- PASS  ::dTestNamespace::cmdA/1 (0.00s)

Total: 9,  Passed: 6,  Skipped: 0,  Failed: 3
} -result [dict create total 9 passed 6 skipped 0 failed 3]


test runTests-6 {Just test certain tests using -match} -body {
  xproc::runTests -verbose 2 -match {*::M* ::ad*ums4 *2 ::aTest*}
} -output {=== RUN   ::addNums2/1
--- FAIL  ::addNums2/1 (0.00s)
          (1) got: 5, want: 18
=== SKIP   ::addNums3/1
=== RUN   ::addNums4/1
--- PASS  ::addNums4/1 (0.00s)
=== SKIP   ::addNums5/1
=== SKIP   ::subNums/1
=== RUN   ::aTestNamespace::cmdA/1
--- PASS  ::aTestNamespace::cmdA/1 (0.00s)
=== RUN   ::aTestNamespace::cmdB/1
--- PASS  ::aTestNamespace::cmdB/1 (0.00s)
=== RUN   ::aTestNamespace::cmdC/1
--- PASS  ::aTestNamespace::cmdC/1 (0.00s)
=== SKIP   ::dTestNamespace::cmdA/1

Total: 9,  Passed: 4,  Skipped: 4,  Failed: 1
} -result [dict create total 9 passed 4 skipped 4 failed 1]


test runTests-7 {-verbose 0 should produce no output to stdout} -body {
  xproc::runTests -verbose 0
} -output {} -result [dict create total 9 passed 6 skipped 0 failed 3]


test descriptions-1 {Ensure there is a description for each exported xproc command} -body {
  foreach cmd [info commands ::xproc::*] {
    if {[regexp {^::xproc::[a-z]+.*$} $cmd]} {lappend exportedCommands $cmd}
  }
  set numXprocExportedCommands [llength $exportedCommands]
  set numXprocDescriptions [dict size [xproc::descriptions -match {*xproc*}]]
  list $numXprocExportedCommands $numXprocDescriptions
} -cleanup {
  xproc::remove descriptions -match {*xproc*}
} -result {9 9}


test descriptions-2 {Return descriptions} -body {
  xproc::descriptions
} -result [dict create ::addNums2 {Add two numbers together and return the result

This could work as follows:
  addNums2 7 9      ; # Would return 16} \
::addNums3 {Add two numbers together and return the result

This could work as follows:
  addNums3 7 9      ; # Would return 16} \
::addNums4 {Add two numbers together and return the result

This could work as follows:
  addNums4 7 9      ; # Would return 16} \
::addNums5 {Add two numbers together and return the result

This could work as follows:
  addNums5 7 9      ; # Would return 16} \
::subNums {Subtract one number from another and return the result

This could work as follows:
  subNums 7 9      ; # Would return -2} \
::aTestNamespace::cmdA {this is a description of cmdA} \
::aTestNamespace::cmdB {this is a description of cmdB} \
::aTestNamespace::cmdC {this is a description of cmdC} \
::cTestNamespace::cmdA {this is a description of cmdA}]


test descriptions-3 {Return specified descriptions using -match} -body {
  xproc::descriptions -match {addNums5 ::addNums4 *ubN* *cmdA*}
} -result [dict create ::addNums4 {Add two numbers together and return the result

This could work as follows:
  addNums4 7 9      ; # Would return 16} \
::subNums {Subtract one number from another and return the result

This could work as follows:
  subNums 7 9      ; # Would return -2} \
::aTestNamespace::cmdA {this is a description of cmdA} \
::cTestNamespace::cmdA {this is a description of cmdA}]


cleanupTests
