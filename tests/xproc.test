package require tcltest
namespace import tcltest::*

# Add module dir to tm paths
set ThisScriptDir [file dirname [info script]]
set ModuleDir [file normalize [file join $ThisScriptDir ..]]
::tcl::tm::path add $ModuleDir

source [file join $ThisScriptDir test_helpers.tcl]

package require xproc


################################
# tcltest is at bottom of file
################################


xproc::test xproc::proc {{t} {
  # Check errors
  set cases {
    {input {xproc::Dummy-1 {} {} -bob}
     returnCodes {error} result "unknown option: -bob"}
    {input {xproc::Dummy-2 {} {} bob}
     returnCodes {error} result "invalid number of arguments"}
    {input {xproc::Dummy-3 {a b} {
              expr {$a+$b}
            } -test {{t} {
              set got [xproc::Dummy-3 2 3]
              set want 5
              if {$got != $want} {
                xproc::fail $t "got: $got, want: $want"
              }
            }} -description {Add two numbers together}}
     passed 1 failed 0 minTotal 5 maxTotal 50}

  }
  xproc::testCases $t $cases {{case} {
    try {
      dict with case {
        xproc::proc {*}$input
        set gotSummary [xproc::runTests -match {::xproc::Dummy-*} -verbose 0]
        set wantDescriptions [
          dict create ::xproc::Dummy-3 {Add two numbers together}
        ]
        dict with gotSummary {
          if {$passed != $passed || $failed != $failed ||
              $total <= $minTotal || $total >= $maxTotal} {
            return -code error "summary incorrect - got: $gotSummary"
          }
        }
        set gotDescriptions [xproc::descriptions -match {::xproc::Dummy-*}]
        if {$gotDescriptions ne $wantDescriptions} {
          return -code error \
              "descriptions - got: $gotDescriptions, want: $wantDescriptions"
        }
      }
    } finally {
      xproc::remove all -match {::xproc::Dummy-*}
      catch {rename xproc::[lindex $input 0] ""}
    }
  }}
}}


xproc::test -id 1 xproc::remove {{t} {
  # Test errors
  set cases {
    {input {all -fred}
     returnCodes {error} result "unknown option: -fred"}
    {input {bob}
     returnCodes {error} result "unknown type: bob"}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {xproc::remove {*}$input}
  }}
}}

xproc::test -id 2 xproc::remove {{t} {
  try {
    for {set n 1} {$n <= 3} {incr n} {
      xproc::proc xproc::Dummy-$n {a b} {
        expr {$a+$b}
      } -test {{t} {
        set got [xproc::Dummy-3 2 3]
        set want 5
        if {$got != $want} {
          xproc::fail $t "got: $got, want: $want"
        }
      }} -description {Add two numbers together}
    }
    xproc::remove tests -match {*Dummy-2}
    set gotSummary [xproc::runTests -match {::xproc::Dummy-*} -verbose 0]
    dict with gotSummary {
      if {$passed != 2 || $failed != 0 || $total < 5 || $total > 100} {
        xproc::fail $t \
            "after remove tests Dummy-2 - summary incorrect - got: $gotSummary"
      }
    }
    xproc::remove descriptions -match {*Dummy-3}
    set gotDescriptions [xproc::descriptions -match {::xproc::Dummy-*}]
    set gotDescriptionProcNames [dict keys $gotDescriptions]
    set wantDescriptionProcNames {::xproc::Dummy-1 ::xproc::Dummy-2}
    if {$gotDescriptionProcNames ne $wantDescriptionProcNames} {
      xproc::fail $t \
          "after remove descriptions Dummy-3 - descriptions - got keys: $gotDescriptionProcNames, want: $wantDescriptionProcNames"
    }
    xproc::remove all -match {::xproc::Dummy-*}
    set gotSummary [xproc::runTests -match {::xproc::Dummy-*} -verbose 0]
    dict with gotSummary {
      if {$passed != 0 || $failed != 0 || $total < 5 || $total > 100} {
        xproc::fail $t \
            "after remove all Dummy-* - summary incorrect - got: $gotSummary"
      }
    }
    set gotDescriptions [xproc::descriptions -match {::xproc::Dummy-*}]
    set gotDescriptionProcNames [dict keys $gotDescriptions]
    if {[llength $gotDescriptionProcNames] != 0} {
      xproc::fail $t \
          "after remove descriptions all Dummy-* descriptions - got keys: $gotDescriptionProcNames, want: $wantDescriptionProcNames"
    }
  } finally {
    xproc::remove all -match {::xproc::Dummy-*}
    rename xproc::Dummy-1 ""
    rename xproc::Dummy-2 ""
    rename xproc::Dummy-3 ""
  }
}}

xproc::test -id 1 xproc::test {{t} {
  # Test errors
  set cases {
    {input {DummyNotExist}
     returnCodes {error}
     result {invalid number of arguments}}
    {input {DummyNotExist {{t} {}}}
     returnCodes {error}
     result {procedureName doesn't exist: DummyNotExist}}
    {input {-id fred DummyNotExist {{t} {}}}
     returnCodes {error}
     result {invalid id: fred}}
    {input {-id 0 DummyNotExist {{t} {}}}
     returnCodes {error}
     result {invalid id: 0}}
    {input {-bob DummyNotExist {{t} {}}}
     returnCodes {error}
     result {unknown option: -bob}}
    {input {-id 1 xproc::test {{t} {}}}
     returnCodes {error}
     result {test already exists for id: 1}}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {xproc::test {*}$input}
  }}
}}

xproc::test -id 2 xproc::test {{t} {
  # Test adding of tests
  xproc::test -- ::TestHelpers::addNums {{t} {
    set got [::TestHelpers::addNums 7 8 9]
    set want 24
    if {$got != $want} {xproc::fail $t "got: $got, want: $want"}
  }}
  xproc::test -id 2 ::TestHelpers::addNums {{t} {
    set got [::TestHelpers::addNums 1 2 3]
    set want 6
    if {$got != $want} {xproc::fail $t "got: $got, want: $want"}
  }}
  try {
    set summary [xproc::runTests -verbose 0 -match {::TestHelpers::addNums}]
    set wantPassed 2
    set wantFailed 0
    dict with summary {
      if {$passed != $wantPassed} {
        xproc::fail $t "got passed: $passed, want: $wantPassed"
      }
      if {$failed != $wantFailed} {
        xproc::fail $t "got failed: $failed, want: $wantFailed"
      }
    }
  } finally {
    xproc::remove all -match {::TestHelpers::addNums}
  }
}}


xproc::test -id 1 xproc::runTests {{t} {
  # Run all xproc tests except this one to prevent an infinite loop
  set ch [TestHelpers::channelMonitor new]
  set tests [
    dict filter [xproc::tests -match {*xproc::*}] script {k v} {
      expr {![string match "*xproc::runTests" $k]}
    }
  ]
  set procNames [dict keys $tests]
  set summary [xproc::runTests -verbose 1 -channel $ch -match $procNames]
  dict with summary {
    set wantTotal [expr {$passed+$failed+$skipped}]
    if {$total != $wantTotal} {
      xproc::fail $t "got total: $total, want: $wantTotal"
    }
    if {$passed < 5} {
      xproc::fail $t "got passed: $passed, want: passed >= 5"
    }
    if {$skipped != 4} {
      xproc::fail $t "got skipped: $skipped, want: 4"
    }
    if {$failed != 0} {xproc::fail $t "got failed: $failed, want: 0"}
  }

  set wantChannelOutput "\nTotal: \\d+,  Passed: \\d+,  Skipped: 4,  Failed: 0\n"
  set channelOutput [TestHelpers::channelMonitor getWriteData $ch]
  if {![regexp $wantChannelOutput $channelOutput]} {
    xproc::fail $t \
        "got channelOutput: $channelOutput, want: $wantChannelOutput"
  }
  close $ch
}}


xproc::test -id 2 xproc::runTests {{t} {
  # Check timings work
  xproc::test -id 1 ::TestHelpers::waitMS {{t} {
    set timeStart [clock microseconds]
    ::TestHelpers::waitMS 100
    set timeEnd [clock microseconds]
    set timeElapsed [expr {$timeEnd-$timeStart}]
    if {$timeElapsed < 100000 || $timeElapsed > 1000000} {
      xproc::fail $t  "timeElapsed: $timeElapsed"
    }
  }}
  xproc::test -id 2 ::TestHelpers::waitMS {{t} {
    set timeStart [clock microseconds]
    ::TestHelpers::waitMS 150
    xproc::fail $t  "here is an error"
  }}
  set ch [TestHelpers::channelMonitor new]
  try {
    xproc::runTests -verbose 2 -channel $ch -match {*TestHelpers::waitMS}
    set channelOutput [TestHelpers::channelMonitor::getWriteData $ch]
    set lines [split $channelOutput "\n"]
    set captureLines {}
    foreach line $lines {
      if {[string match {--- FAIL*} $line] ||
          [string match {--- PASS*} $line]} {
        lappend captureLines $line
      }
    }
    set wantCaptureLines [
      list "--- PASS  ::TestHelpers::waitMS/1 (0.10s)" \
           "--- FAIL  ::TestHelpers::waitMS/2 (0.15s)"
    ]
    if {$captureLines ne $wantCaptureLines} {
      xproc::fail $t \
          "got capture lines: $captureLines, want: $wantCaptureLines"
    }
  } finally {
    xproc::remove all -match {*TestHelpers::waitMS}
    close $ch
  }
}}


xproc::test -id 3 xproc::runTests {{t} {
  # -verbose 0 should produce no output to stdout
  set ch [TestHelpers::channelMonitor new]
  try {
    xproc::runTests -verbose 0 -channel $ch -match {*xproc::t*}
    set channelOutput [TestHelpers::channelMonitor::getWriteData $ch]
    if {$channelOutput ne ""} {
      xproc::fail $t "incorrect channel output: $channelOutput"
    }
  } finally {
    close $ch
  }
}}


xproc::test -id 4 xproc::runTests {{t} {
  # -verbose 1 should only list failing tests and summary
  xproc::test -id 1 ::TestHelpers::addNums {{t} {
    set got [::TestHelpers::addNums 7 8 9]
    set want 24
    if {$got != $want} {xproc::fail $t "got: $got, want: $want"}
  }}
  xproc::test -id 2 ::TestHelpers::addNums {{t} {
    xproc::fail $t  "here is an error"
  }}
  set ch [TestHelpers::channelMonitor new]
  try {
    xproc::runTests -verbose 1 -channel $ch -match {*TestHelpers::addNums}
    set channelOutput [TestHelpers::channelMonitor::getWriteData $ch]
    set lines [split $channelOutput "\n"]
    set captureLines {}
    set gotNums [dict create numFAIL 0 numPASS 0 numSKIP 0 numSummary 0]
    foreach line $lines {
      if {[string match {--- FAIL*} $line]} {dict incr gotNums numFAIL}
      if {[string match {--- PASS*} $line]} {dict incr gotNums numPASS}
      if {[string match {--- SKIP*} $line]} {dict incr gotNums numSKIP}
      if {[string match {Total:*Passed:*Skipped:*Failed:*} $line]} {
        dict incr gotNums numSummary
      }
    }
    set wantNums {numFAIL 1 numPASS 0 numSKIP 0 numSummary 1}
    if {$gotNums ne $wantNums} {
      xproc::fail $t \
          "got nums: $gotNums, want: $wantNums"
    }
  } finally {
    xproc::remove all -match {*TestHelpers::waitMS}
    close $ch
  }
}}


xproc::test -id 1 xproc::descriptions {{t} {
  set cases {
    {input {-match {*xproc::descriptions *xproc::test}} minNum 2 maxNum 2}
    {input {-match {*xproc*}} minNum 5 maxNum 100}
    {input {} minNum 5 maxNum 25}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {
      set got [xproc::descriptions {*}$input]
      set numGot [dict size $got]
      if {$numGot < $minNum || $numGot > $maxNum} {
        return -code error \
            "got num descriptions: $numGot, want >= $minNum && <= $maxNum"
      }
    }
  }}
}}


xproc::test -id 2 xproc::descriptions {{t} {
  # Check that there is a description for each exported xproc command
  foreach cmd [info commands ::xproc::*] {
    if {[regexp {^::xproc::[a-z]+.*$} $cmd]} {lappend exportedCommands $cmd}
  }
  set numXprocExportedCommands [llength $exportedCommands]
  if {$numXprocExportedCommands < 5} {
    return -code error "too few exported xproc commands: $numXprocExportedCommands"
  }
  set numXprocDescriptions [dict size [xproc::descriptions -match {*xproc*}]]
  if {$numXprocExportedCommands != $numXprocDescriptions} {
    xproc::fail $t "got num xproc descriptions: $numXprocDescriptions, want: $numXprocExportedCommands"
  }
}}


xproc::test -id 3 xproc::descriptions {{t} {
  # Check that descriptions are returned properly
  xproc::describe TestHelpers::addNums {
    A function to add a sequence of numbers together
  }
  xproc::describe TestHelpers::waitMS {
    Wait for a specified number of milliseconds
  }
  try {
    set got [
      xproc::descriptions -match {*TestHelpers::addNums *TestHelpers::waitMS}
    ]
    set want [
      dict create ::TestHelpers::addNums \
          {A function to add a sequence of numbers together} \
          ::TestHelpers::waitMS {Wait for a specified number of milliseconds}
    ]
    if {$got ne $want} {
      xproc::fail $t "got: $got, want: $want"
    }
  } finally {
    xproc::remove descriptions \
        -match {*TestHelpers::addNums *TestHelpers::waitMS}
  }
}}


xproc::test xproc::describe {{t} {
  set cases {
    {input {DummyNotExist {{t} {}}}
     returnCodes {error}
     result {procedureName doesn't exist: DummyNotExist}}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {xproc::describe {*}$input}
  }}
}}


xproc::test xproc::tests {{t} {
  set cases {
    {input {-match {*xproc::tests *xproc::test}} minNum 2 maxNum 2}
    {input {-match {*xproc*}} minNum 5 maxNum 100}
    {input {} minNum 5 maxNum 25}
  }
  xproc::testCases $t $cases {{case} {
    dict with case {
      set got [xproc::tests {*}$input]
      set numGot [dict size $got]
      if {$numGot < $minNum || $numGot > $maxNum} {
        return -code error \
            "got num tests: $numGot, want >= $minNum && <= $maxNum"
      }
    }
  }}
}}


test runTests-1 {Test ::xproc::test tests} -body {
  xproc::runTests -match {*::xproc*}
} -output {
Total: 21,  Passed: 21,  Skipped: 0,  Failed: 0
} -result {total 21 passed 21 skipped 0 failed 0}

cleanupTests
